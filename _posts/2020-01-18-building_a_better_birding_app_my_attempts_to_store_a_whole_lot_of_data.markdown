---
layout: post
title:      "Building a Better Birding App: My Attempts to Store a Whole Lot of Data"
date:       2020-01-19 04:18:57 +0000
permalink:  building_a_better_birding_app_my_attempts_to_store_a_whole_lot_of_data
---


A couple weeks ago, I decided to recreate a simplified version of ebird, a website designed for birdwatchers to record sightings. I used the powerful Ruby gem Sinatra. In nontechnical terms, Sinatra essentially creates websites that can access and display data stored in tables on your computer. In this case, I had two tables – "Birds" and "Regions" – which stored information about different bird species and the regions where they live.

One of my favorite things about ebird is the way the website only presents birdwatchers with a list of species common in their area. On ebird, birdwatchers create "checklists" by checking off each species they saw at a certain location on a certain day. Instead of displaying, say, all the birds in the US, ebird will only display the species usually seen in the location where the user went birding. To display bird species not usually seen in the area, the user must press a small button at the bottom of the page labelled "Show Rarities." There are several reasons ebird does not display all the birds in the US. First, it's more convenient for users: no one wants to scroll through a list of 900 birds to find the fifteen species they saw on a hike. However, giving users the option to record rare species isn't just impractical, it can be destructive and even dangerous. Websites designed for birdwatchers are important sources of citizen data. Each year, ebird publishes studies that draw conclusions about bird populations and ranges based on the data submitted by users. If too many users reported seeing birds from other states and countries, ebird's scientific studies would be rendered useless. In order to prevent its data from being corrupted, ebird makes it harder for users to record species that are rare visitors to their state. (ebird also requires any users who report a rarity to submit either photo evidence or a long, in-depth description, and truly rare birds require both photo evidence and multiple collaborating reports).

To re-create ebird's filtering capacity, I first needed to associate each bird species with the regions where it lives. This way, I could determine which birds I expect users to see in which states. I created two tables called "Birds" and “Regions,” to store information about individual birds and regions. I then created a few sample bird species and regions. Whenever I create a new bird, the program Activerecord automatically stores data about that bird in the table called “Birds”, and the program SQL automatically assigns each row of the table an ID. The IDs are SQL’s way of giving each piece of information (in this case, each bird) a unique identifier. Let’s say I created four birds and gave each a common name, a latin name, and a description. The table would look a bit like this:
Birds Table

(Keep in mind that there is also a Regions table which stores info about the regions I create and gives each region a unique ID).

I now needed to associate the birds stored in the Bird table with the regions stored in the Region table. Normally, I would try to associate the tables using a "foreign key" column in one table or the other. For example, if I wanted to associate each bird with a region, I would create a column in the "birds" table to store the id of the region where each bird lives (ie, if I want the model to know that the eastern bluebird lives in Wyoming, I would put Wyoming's id in the Eastern bluebird's foreign key column). But, of course, that model doesn't reflect reality: one bird species can live in many different regions. (Programmers call the relationship between birds and regions a "many to many" relationship, since each bird lives in many regions, and there are many birds that live in each region). Since the Eastern bluebird lives in about 20 states, the bluebird's foreign key column would have to contain 20 different region ids. Unfortunately, SQL can only store one number in each cell. 

Fortunately, there's an easy work around: create a"join" table in which each row connects a particular bird with a particular region. The first column of the join table contains the id of the bird, while the second column stores the id of the region you want to associate with the bird. So, if I wanted to connect the Eastern bluebird with 20 different regions, I simply insert 20 rows into the join table. The first cell of all 20 rows would be the ID of the bluebird, and in the second column I’d cycle through the ids of all the places where the bluebird lives. I decided to call the table that joined birds with regions "rangemaps," since a range map provides information about a specific region where a specific bird lives (but doesn’t usually tell us all the places a bird lives or all of the birds that live in a certain place). It looks a bit like this: 


I couldn’t manually create each bird, region and rangemap – there are over 900 bird species that live in the US, and creating all of them by hand would take much too long. I needed to look for places on the web where I could easily and legally get information about all the bird species that live in each state. Once I found that data on the web, I could turn that data into Ruby code using a gem called Nokogiri (a process called “scraping the web”). Fortunately, Wikipedia maintains lists of the birds that live in each state. 

I designed my program to iterate through each list of birds, and create a new range map for each bird that appears the list. For example, my program will first get data from Wikipedia’s list of birds in Alabama. The program will go through the list of birds. If the bird’s already in the table, the program will find the id of the species. If the bird isn’t in the table, the program will insert info about the species into the table, creating a new bird with a unique ID. The program will then create a range map for every bird on the Alabama list, associating each bird’s id with the id of Alabama. 

The first time I ran my program, it worked as intended…kind of. For some reason, Arizona’s bird list misspelled twenty or thirty latin names, and the program didn’t realize the misspelled birds in Arizona represented the same species as correctly-spelled birds elsewhere. There was also a larger problem: rarities. Wikipedia doesn't just list the birds that live and breed in each state; Wikipedia lists *every bird ever recorded in each state.* For instance, twenty years ago, an escaped pet flamingo was observed flying around Boston. As a result, Wikipedia considers the American flamingo an "accidental" visitor in Massachusetts. I tweaked my program to ignore the rarities (any species with an “A”, “R” or “C” after their name), deleted the data in the birds and regions table, and scraped again. 

It was a mess. Birds that should live only in Texas were showing up on the list of Connecticut birds. Birds that should live only in Northern states were showing up on lists of Texas birds. Why was this happening?

My first clue: even though only fifty regions existed, some bird species were associated with eighty or ninety different regions. This must mean that somewhere along the line, some bird species were being associated with the same regions twice. Since birds are associated with regions through rangemaps, my range maps model must be breaking.

I’d cleared the bird and region tables, but not the range map table. Then, I’d created new birds with the same IDs as the birds I just destroyed. For instance, when I first ran the program, the chipping sparrow was assigned the ID 8. The rangemap (8, 1) associated bird 8 (the chipping sparrow) with region 1 (Alabama). I then destroyed the information about the chipping sparrow and reset then bird table (meaning, when I start creating birds again, the IDs start back at zero). When I ran the program again, the elf owl was assigned ID 8. However, the range map still exists, telling the program that bird 8 (now the elf owl) should be associated with the region 1 (Alabama – not where elf owls live). So, suddenly, my program thinks that elf owls live in Alabama.

Join tables are often invisible and, therefore, easy to ignore. Unlike a bird or a state, you could not see range maps displayed on the pages of my website. It was easy for me to pay attention to the birds and states displayed on my website and dismiss the invisible, abstract entities connecting the birds and states. However, it’s the join tables that connect the data and made the whole program work. 
